package handlers

import (
	"io"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/stitts-dev/dfs-sim/services/user-service/internal/models"
	"github.com/stitts-dev/dfs-sim/services/user-service/internal/services"
)

// StripeHandler handles Stripe-related endpoints
type StripeHandler struct {
	stripeService *services.StripeService
	userService   *services.UserService
}

// NewStripeHandler creates a new Stripe handler
func NewStripeHandler(stripeService *services.StripeService, userService *services.UserService) *StripeHandler {
	return &StripeHandler{
		stripeService: stripeService,
		userService:   userService,
	}
}

// CreateSubscriptionRequest represents subscription creation request
type CreateSubscriptionRequest struct {
	PriceID string `json:"price_id" binding:"required"`
}

// CreateSubscriptionResponse represents subscription creation response
type CreateSubscriptionResponse struct {
	SubscriptionID   string  `json:"subscription_id"`
	ClientSecret     string  `json:"client_secret"`
	Status           string  `json:"status"`
	LatestInvoiceURL *string `json:"latest_invoice_url,omitempty"`
}

// CreateCustomer creates a Stripe customer for the authenticated user
// POST /api/v1/users/:id/stripe-customer
func (h *StripeHandler) CreateCustomer(c *gin.Context) {
	userIDStr := c.Param("id")
	userID, err := strconv.ParseUint(userIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	// Get user from database
	user, err := models.GetUserByID(h.userService.GetDB(), uint(userID))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// Create or get existing Stripe customer
	customer, err := h.stripeService.CreateCustomer(user)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create customer"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"customer_id": customer.ID,
		"user_id":     user.ID,
		"created":     customer.Created,
	})
}

// CreateSubscription creates a subscription for the authenticated user
// POST /api/v1/subscriptions
func (h *StripeHandler) CreateSubscription(c *gin.Context) {
	var req CreateSubscriptionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get user ID from JWT token (this would be set by auth middleware)
	userIDInterface, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	userID, ok := userIDInterface.(uint)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user ID in token"})
		return
	}

	// Get user from database
	user, err := models.GetUserByID(h.userService.GetDB(), userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// Create subscription
	subscription, err := h.stripeService.CreateSubscription(user, req.PriceID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create subscription"})
		return
	}

	// Prepare response
	response := CreateSubscriptionResponse{
		SubscriptionID: subscription.ID,
		Status:         string(subscription.Status),
	}

	// Add client secret if payment intent exists
	if subscription.LatestInvoice != nil && subscription.LatestInvoice.PaymentIntent != nil {
		response.ClientSecret = subscription.LatestInvoice.PaymentIntent.ClientSecret
	}

	// Add invoice URL if hosted invoice exists
	if subscription.LatestInvoice != nil && subscription.LatestInvoice.HostedInvoiceURL != "" {
		response.LatestInvoiceURL = &subscription.LatestInvoice.HostedInvoiceURL
	}

	c.JSON(http.StatusOK, response)
}

// CancelSubscription cancels a user's subscription
// DELETE /api/v1/subscriptions/:subscription_id
func (h *StripeHandler) CancelSubscription(c *gin.Context) {
	subscriptionID := c.Param("subscription_id")
	if subscriptionID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Subscription ID required"})
		return
	}

	// Get user ID from JWT token
	userIDInterface, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	userID, ok := userIDInterface.(uint)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user ID in token"})
		return
	}

	// Verify user owns this subscription (security check)
	user, err := models.GetUserByID(h.userService.GetDB(), userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// Cancel subscription
	subscription, err := h.stripeService.CancelSubscription(subscriptionID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to cancel subscription"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"subscription_id":      subscription.ID,
		"status":               subscription.Status,
		"cancel_at_period_end": subscription.CancelAtPeriodEnd,
		"current_period_end":   subscription.CurrentPeriodEnd,
	})
}

// GetSubscriptionStatus gets the subscription status for the authenticated user
// GET /api/v1/subscriptions/status
func (h *StripeHandler) GetSubscriptionStatus(c *gin.Context) {
	// Get user ID from JWT token
	userIDInterface, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	userID, ok := userIDInterface.(uint)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user ID in token"})
		return
	}

	// Get user from database
	user, err := models.GetUserByID(h.userService.GetDB(), userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// Get subscription tier details
	tier, err := user.GetTier(h.userService.GetDB())
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get tier details"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"user_id":                    user.ID,
		"subscription_tier":          user.SubscriptionTier,
		"subscription_status":        user.SubscriptionStatus,
		"subscription_expires_at":    user.SubscriptionExpiresAt,
		"is_active":                  user.IsSubscriptionActive(),
		"monthly_optimizations_used": user.MonthlyOptimizationsUsed,
		"monthly_simulations_used":   user.MonthlySimulationsUsed,
		"tier_details": gin.H{
			"name":                   tier.Name,
			"price_cents":            tier.PriceCents,
			"monthly_optimizations":  tier.MonthlyOptimizations,
			"monthly_simulations":    tier.MonthlySimulations,
			"ai_recommendations":     tier.AIRecommendations,
			"bank_verification":      tier.BankVerification,
			"priority_support":       tier.PrioritySupport,
		},
	})
}

// WebhookHandler handles Stripe webhook events
// POST /api/v1/webhooks/stripe
func (h *StripeHandler) WebhookHandler(c *gin.Context) {
	// Read the request body
	payload, err := io.ReadAll(c.Request.Body)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to read request body"})
		return
	}

	// Get Stripe signature header
	signature := c.GetHeader("Stripe-Signature")
	if signature == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing Stripe signature"})
		return
	}

	// Process webhook
	err = h.stripeService.ProcessWebhook(payload, signature)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to process webhook"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"received": true})
}

// GetSubscriptionTiers returns all available subscription tiers
// GET /api/v1/subscription-tiers
func (h *StripeHandler) GetSubscriptionTiers(c *gin.Context) {
	tiers, err := models.GetAllSubscriptionTiers(h.userService.GetDB())
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get subscription tiers"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"tiers": tiers,
	})
}

// EnsureCustomer ensures the authenticated user has a Stripe customer
// Used internally by other endpoints that need Stripe customer to exist
func (h *StripeHandler) EnsureCustomer(c *gin.Context) {
	userIDInterface, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	userID, ok := userIDInterface.(uint)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user ID in token"})
		return
	}

	// Get user from database
	user, err := models.GetUserByID(h.userService.GetDB(), userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// Ensure Stripe customer exists
	err = h.stripeService.EnsureCustomerExists(user)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to ensure customer exists"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"stripe_customer_id": user.StripeCustomerID,
	})
}