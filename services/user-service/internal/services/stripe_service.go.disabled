package services

import (
	"fmt"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/stitts-dev/dfs-sim/services/user-service/internal/models"
	"github.com/stitts-dev/dfs-sim/shared/pkg/config"
	"github.com/stitts-dev/dfs-sim/shared/pkg/database"
	"github.com/stripe/stripe-go/v76"
	"github.com/stripe/stripe-go/v76/customer"
	"github.com/stripe/stripe-go/v76/subscription"
	"github.com/stripe/stripe-go/v76/webhook"
)

// StripeService handles Stripe operations
type StripeService struct {
	db            *database.DB
	config        *config.Config
	logger        *logrus.Logger
	webhookSecret string
}

// NewStripeService creates a new Stripe service
func NewStripeService(db *database.DB, cfg *config.Config, logger *logrus.Logger) *StripeService {
	// Initialize Stripe with secret key
	stripe.Key = cfg.GetString("STRIPE_SECRET_KEY")
	
	return &StripeService{
		db:            db,
		config:        cfg,
		logger:        logger,
		webhookSecret: cfg.GetString("STRIPE_WEBHOOK_SECRET"),
	}
}

// CreateCustomer creates a Stripe customer for a user
func (s *StripeService) CreateCustomer(user *models.User) (*stripe.Customer, error) {
	// Skip if customer already exists
	if user.StripeCustomerID != nil && *user.StripeCustomerID != "" {
		s.logger.WithField("user_id", user.ID).Info("User already has Stripe customer")
		return s.GetCustomer(*user.StripeCustomerID)
	}

	// Prepare customer data
	params := &stripe.CustomerParams{
		Phone: stripe.String(user.PhoneNumber),
		Metadata: map[string]string{
			"user_id":      fmt.Sprintf("%d", user.ID),
			"service":      "dfs-optimizer",
			"phone_number": user.PhoneNumber,
		},
	}

	// Add name if available
	if user.FirstName != nil && user.LastName != nil {
		params.Name = stripe.String(fmt.Sprintf("%s %s", *user.FirstName, *user.LastName))
	}

	// Add email if available
	if user.Email != nil {
		params.Email = stripe.String(*user.Email)
	}

	// Create customer in Stripe
	stripeCustomer, err := customer.New(params)
	if err != nil {
		s.logger.WithError(err).Error("Failed to create Stripe customer")
		return nil, fmt.Errorf("failed to create Stripe customer: %w", err)
	}

	// Update user with Stripe customer ID
	customerID := stripeCustomer.ID
	err = s.db.Model(user).UpdateColumn("stripe_customer_id", customerID).Error
	if err != nil {
		s.logger.WithError(err).Error("Failed to update user with Stripe customer ID")
		return nil, fmt.Errorf("failed to update user with customer ID: %w", err)
	}

	user.StripeCustomerID = &customerID

	// Log successful creation
	s.logger.WithFields(logrus.Fields{
		"user_id":           user.ID,
		"stripe_customer_id": customerID,
		"phone_number":      user.PhoneNumber,
	}).Info("Successfully created Stripe customer")

	return stripeCustomer, nil
}

// GetCustomer retrieves a Stripe customer
func (s *StripeService) GetCustomer(customerID string) (*stripe.Customer, error) {
	return customer.Get(customerID, nil)
}

// CreateSubscription creates a subscription for a user
func (s *StripeService) CreateSubscription(user *models.User, priceID string) (*stripe.Subscription, error) {
	// Ensure customer exists
	if user.StripeCustomerID == nil || *user.StripeCustomerID == "" {
		_, err := s.CreateCustomer(user)
		if err != nil {
			return nil, fmt.Errorf("failed to create customer: %w", err)
		}
	}

	// Create subscription
	params := &stripe.SubscriptionParams{
		Customer: stripe.String(*user.StripeCustomerID),
		Items: []*stripe.SubscriptionItemsParams{
			{
				Price: stripe.String(priceID),
			},
		},
		PaymentBehavior: stripe.String("default_incomplete"),
		PaymentSettings: &stripe.SubscriptionPaymentSettingsParams{
			SaveDefaultPaymentMethod: stripe.String("on_subscription"),
		},
		Expand: []*string{stripe.String("latest_invoice.payment_intent")},
		Metadata: map[string]string{
			"user_id": fmt.Sprintf("%d", user.ID),
			"service": "dfs-optimizer",
		},
	}

	sub, err := subscription.New(params)
	if err != nil {
		s.logger.WithError(err).Error("Failed to create Stripe subscription")
		return nil, fmt.Errorf("failed to create subscription: %w", err)
	}

	s.logger.WithFields(logrus.Fields{
		"user_id":         user.ID,
		"subscription_id": subscription.ID,
		"price_id":        priceID,
	}).Info("Successfully created Stripe subscription")

	return subscription, nil
}

// CancelSubscription cancels a user's subscription
func (s *StripeService) CancelSubscription(subscriptionID string) (*stripe.Subscription, error) {
	params := &stripe.SubscriptionCancelParams{
		CancelAtPeriodEnd: stripe.Bool(true),
	}

	sub, err := subscription.Cancel(subscriptionID, params)
	if err != nil {
		s.logger.WithError(err).Error("Failed to cancel Stripe subscription")
		return nil, fmt.Errorf("failed to cancel subscription: %w", err)
	}

	s.logger.WithField("subscription_id", subscriptionID).Info("Successfully cancelled Stripe subscription")
	return subscription, nil
}

// ProcessWebhook processes Stripe webhook events
func (s *StripeService) ProcessWebhook(payload []byte, sig string) error {
	event, err := webhook.ConstructEvent(payload, sig, s.webhookSecret)
	if err != nil {
		s.logger.WithError(err).Error("Failed to verify webhook signature")
		return fmt.Errorf("failed to verify webhook: %w", err)
	}

	s.logger.WithField("event_type", event.Type).Info("Processing Stripe webhook")

	switch event.Type {
	case "customer.subscription.created":
		return s.handleSubscriptionCreated(event)
	case "customer.subscription.updated":
		return s.handleSubscriptionUpdated(event)
	case "customer.subscription.deleted":
		return s.handleSubscriptionDeleted(event)
	case "invoice.payment_succeeded":
		return s.handlePaymentSucceeded(event)
	case "invoice.payment_failed":
		return s.handlePaymentFailed(event)
	default:
		s.logger.WithField("event_type", event.Type).Info("Unhandled webhook event type")
	}

	return nil
}

// handleSubscriptionCreated processes subscription creation events
func (s *StripeService) handleSubscriptionCreated(event stripe.Event) error {
	var subscription stripe.Subscription
	err := event.GetObjectValue("object", &subscription)
	if err != nil {
		return fmt.Errorf("failed to parse subscription: %w", err)
	}

	// Get user by Stripe customer ID
	user, err := s.getUserByStripeCustomerID(subscription.Customer.ID)
	if err != nil {
		return fmt.Errorf("failed to find user: %w", err)
	}

	// Update user subscription status
	updates := map[string]interface{}{
		"subscription_status":     "active",
		"subscription_expires_at": time.Unix(subscription.CurrentPeriodEnd, 0),
	}

	// Determine subscription tier from price ID
	if len(subscription.Items.Data) > 0 {
		priceID := subscription.Items.Data[0].Price.ID
		tier := s.getTierFromPriceID(priceID)
		if tier != "" {
			updates["subscription_tier"] = tier
		}
	}

	err = s.db.Model(user).Updates(updates).Error
	if err != nil {
		return fmt.Errorf("failed to update user subscription: %w", err)
	}

	s.logger.WithFields(logrus.Fields{
		"user_id":         user.ID,
		"subscription_id": subscription.ID,
	}).Info("Successfully processed subscription creation")

	return nil
}

// handleSubscriptionUpdated processes subscription update events
func (s *StripeService) handleSubscriptionUpdated(event stripe.Event) error {
	var subscription stripe.Subscription
	err := event.GetObjectValue("object", &subscription)
	if err != nil {
		return fmt.Errorf("failed to parse subscription: %w", err)
	}

	// Get user by Stripe customer ID
	user, err := s.getUserByStripeCustomerID(subscription.Customer.ID)
	if err != nil {
		return fmt.Errorf("failed to find user: %w", err)
	}

	// Update user subscription status
	updates := map[string]interface{}{
		"subscription_status":     subscription.Status,
		"subscription_expires_at": time.Unix(subscription.CurrentPeriodEnd, 0),
	}

	err = s.db.Model(user).Updates(updates).Error
	if err != nil {
		return fmt.Errorf("failed to update user subscription: %w", err)
	}

	s.logger.WithFields(logrus.Fields{
		"user_id":         user.ID,
		"subscription_id": subscription.ID,
		"status":          subscription.Status,
	}).Info("Successfully processed subscription update")

	return nil
}

// handleSubscriptionDeleted processes subscription deletion events
func (s *StripeService) handleSubscriptionDeleted(event stripe.Event) error {
	var subscription stripe.Subscription
	err := event.GetObjectValue("object", &subscription)
	if err != nil {
		return fmt.Errorf("failed to parse subscription: %w", err)
	}

	// Get user by Stripe customer ID
	user, err := s.getUserByStripeCustomerID(subscription.Customer.ID)
	if err != nil {
		return fmt.Errorf("failed to find user: %w", err)
	}

	// Update user to free tier
	updates := map[string]interface{}{
		"subscription_tier":       "free",
		"subscription_status":     "cancelled",
		"subscription_expires_at": nil,
	}

	err = s.db.Model(user).Updates(updates).Error
	if err != nil {
		return fmt.Errorf("failed to update user subscription: %w", err)
	}

	s.logger.WithFields(logrus.Fields{
		"user_id":         user.ID,
		"subscription_id": subscription.ID,
	}).Info("Successfully processed subscription deletion")

	return nil
}

// handlePaymentSucceeded processes successful payment events
func (s *StripeService) handlePaymentSucceeded(event stripe.Event) error {
	var invoice stripe.Invoice
	err := event.GetObjectValue("object", &invoice)
	if err != nil {
		return fmt.Errorf("failed to parse invoice: %w", err)
	}

	// Get user by Stripe customer ID
	user, err := s.getUserByStripeCustomerID(invoice.Customer.ID)
	if err != nil {
		return fmt.Errorf("failed to find user: %w", err)
	}

	// Reset usage for successful payment (new billing period)
	err = user.ResetUsageIfNeeded(s.db)
	if err != nil {
		s.logger.WithError(err).Error("Failed to reset user usage")
	}

	s.logger.WithFields(logrus.Fields{
		"user_id":    user.ID,
		"invoice_id": invoice.ID,
		"amount":     invoice.AmountPaid,
	}).Info("Successfully processed payment")

	return nil
}

// handlePaymentFailed processes failed payment events
func (s *StripeService) handlePaymentFailed(event stripe.Event) error {
	var invoice stripe.Invoice
	err := event.GetObjectValue("object", &invoice)
	if err != nil {
		return fmt.Errorf("failed to parse invoice: %w", err)
	}

	// Get user by Stripe customer ID
	user, err := s.getUserByStripeCustomerID(invoice.Customer.ID)
	if err != nil {
		return fmt.Errorf("failed to find user: %w", err)
	}

	// Update subscription status to past_due
	err = s.db.Model(user).UpdateColumn("subscription_status", "past_due").Error
	if err != nil {
		return fmt.Errorf("failed to update user subscription status: %w", err)
	}

	s.logger.WithFields(logrus.Fields{
		"user_id":    user.ID,
		"invoice_id": invoice.ID,
	}).Warn("Payment failed - updated user status to past_due")

	return nil
}

// Helper methods

// getUserByStripeCustomerID finds a user by Stripe customer ID
func (s *StripeService) getUserByStripeCustomerID(customerID string) (*models.User, error) {
	var user models.User
	err := s.db.Where("stripe_customer_id = ?", customerID).First(&user).Error
	return &user, err
}

// getTierFromPriceID maps Stripe price IDs to subscription tiers
func (s *StripeService) getTierFromPriceID(priceID string) string {
	switch priceID {
	case "price_basic_monthly":
		return "basic"
	case "price_premium_monthly":
		return "premium"
	default:
		return ""
	}
}

// EnsureCustomerExists ensures a user has a Stripe customer, creating one if needed
func (s *StripeService) EnsureCustomerExists(user *models.User) error {
	if user.StripeCustomerID != nil && *user.StripeCustomerID != "" {
		return nil
	}

	_, err := s.CreateCustomer(user)
	return err
}