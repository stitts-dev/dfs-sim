package handlers

import (
	"context"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/sirupsen/logrus"
	"github.com/stitts-dev/dfs-sim/services/sports-data-service/internal/services"
	"github.com/stitts-dev/dfs-sim/shared/pkg/database"
	"github.com/stitts-dev/dfs-sim/shared/types"
)

// EnhancedPlayerHandler handles enhanced player data requests
type EnhancedPlayerHandler struct {
	db                *database.DB
	logger            *logrus.Logger
	playerImporter    *services.ContestPlayerImporter
	playerMatcher     *services.PlayerMatchingService
	tournamentEnricher *services.TournamentDataEnricher
}

// NewEnhancedPlayerHandler creates a new enhanced player handler
func NewEnhancedPlayerHandler(
	db *database.DB,
	logger *logrus.Logger,
	playerImporter *services.ContestPlayerImporter,
	playerMatcher *services.PlayerMatchingService,
	tournamentEnricher *services.TournamentDataEnricher,
) *EnhancedPlayerHandler {
	return &EnhancedPlayerHandler{
		db:                 db,
		logger:             logger,
		playerImporter:     playerImporter,
		playerMatcher:      playerMatcher,
		tournamentEnricher: tournamentEnricher,
	}
}

// GetContestPlayers returns enhanced players for a contest
func (h *EnhancedPlayerHandler) GetContestPlayers(c *gin.Context) {
	contestIDStr := c.Param("contest_id")
	contestID, err := uuid.Parse(contestIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid contest ID"})
		return
	}

	// Get enhanced players
	players, err := h.tournamentEnricher.GetEnhancedPlayersForContest(context.Background(), contestID)
	if err != nil {
		h.logger.WithError(err).Error("Failed to get enhanced players")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get enhanced players"})
		return
	}

	// If no enhanced players found, get contest players
	if len(players) == 0 {
		players, err = h.playerImporter.GetContestPlayers(context.Background(), contestID)
		if err != nil {
			h.logger.WithError(err).Error("Failed to get contest players")
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get contest players"})
			return
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"contest_id":    contestID,
		"player_count":  len(players),
		"players":       players,
	})
}

// GetPlayerStats returns detailed stats for a player
func (h *EnhancedPlayerHandler) GetPlayerStats(c *gin.Context) {
	playerIDStr := c.Param("player_id")
	playerID, err := uuid.Parse(playerIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid player ID"})
		return
	}

	var player types.Player
	if err := h.db.First(&player, playerID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Player not found"})
		return
	}

	// Get player match info if available
	var playerMatch services.PlayerMatch
	matchErr := h.db.Where("player_id = ?", playerID).First(&playerMatch).Error

	response := gin.H{
		"player_id":        player.ID,
		"name":             player.Name,
		"data_source":      player.DataSource,
		"projected_points": player.ProjectedPoints,
		"floor_points":     player.FloorPoints,
		"ceiling_points":   player.CeilingPoints,
		"salary_dk":        player.SalaryDK,
		"salary_fd":        player.SalaryFD,
		"team":             player.Team,
		"position":         player.Position,
		"metadata":         player.Metadata,
		"updated_at":       player.UpdatedAt,
	}

	if matchErr == nil {
		response["match_info"] = gin.H{
			"tournament_player_id": playerMatch.TournamentPlayerID,
			"match_confidence":     playerMatch.MatchConfidence,
			"match_method":         playerMatch.MatchMethod,
		}
	}

	c.JSON(http.StatusOK, response)
}

// GetMatchingStats returns player matching statistics for a contest
func (h *EnhancedPlayerHandler) GetMatchingStats(c *gin.Context) {
	contestIDStr := c.Param("contest_id")
	contestID, err := uuid.Parse(contestIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid contest ID"})
		return
	}

	stats, err := h.playerMatcher.GetMatchingStats(context.Background(), contestID)
	if err != nil {
		h.logger.WithError(err).Error("Failed to get matching stats")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get matching stats"})
		return
	}

	c.JSON(http.StatusOK, stats)
}

// GetEnhancementStats returns enhancement statistics for a contest
func (h *EnhancedPlayerHandler) GetEnhancementStats(c *gin.Context) {
	contestIDStr := c.Param("contest_id")
	contestID, err := uuid.Parse(contestIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid contest ID"})
		return
	}

	stats, err := h.tournamentEnricher.GetEnhancementStats(context.Background(), contestID)
	if err != nil {
		h.logger.WithError(err).Error("Failed to get enhancement stats")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get enhancement stats"})
		return
	}

	c.JSON(http.StatusOK, stats)
}

// TriggerPlayerImport manually triggers player import for a contest
func (h *EnhancedPlayerHandler) TriggerPlayerImport(c *gin.Context) {
	contestIDStr := c.Param("contest_id")
	contestID, err := uuid.Parse(contestIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid contest ID"})
		return
	}

	platform := c.DefaultQuery("platform", "draftkings")

	// Get contest details
	var contest types.Contest
	if err := h.db.First(&contest, contestID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Contest not found"})
		return
	}

	// Trigger import based on platform
	var importErr error
	switch platform {
	case "draftkings":
		importErr = h.playerImporter.ImportDraftKingsGolfContest(context.Background(), contestID, contest.SportID, contest.TournamentID)
	case "fanduel":
		importErr = h.playerImporter.ImportFanDuelGolfContest(context.Background(), contestID, contest.SportID, contest.TournamentID)
	default:
		c.JSON(http.StatusBadRequest, gin.H{"error": "Unsupported platform"})
		return
	}

	if importErr != nil {
		h.logger.WithError(importErr).Error("Failed to import players")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to import players"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":    "Player import triggered successfully",
		"contest_id": contestID,
		"platform":   platform,
	})
}

// TriggerPlayerMatching manually triggers player matching for a contest
func (h *EnhancedPlayerHandler) TriggerPlayerMatching(c *gin.Context) {
	contestIDStr := c.Param("contest_id")
	contestID, err := uuid.Parse(contestIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid contest ID"})
		return
	}

	// This would typically get tournament players from the API
	// For now, we'll return a success message
	c.JSON(http.StatusOK, gin.H{
		"message":    "Player matching triggered successfully",
		"contest_id": contestID,
	})
}

// TriggerEnhancement manually triggers player enhancement for a contest
func (h *EnhancedPlayerHandler) TriggerEnhancement(c *gin.Context) {
	contestIDStr := c.Param("contest_id")
	contestID, err := uuid.Parse(contestIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid contest ID"})
		return
	}

	result, err := h.tournamentEnricher.EnhanceContestPlayers(context.Background(), contestID)
	if err != nil {
		h.logger.WithError(err).Error("Failed to enhance players")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to enhance players"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":          "Player enhancement completed",
		"contest_id":       contestID,
		"tournament_id":    result.TournamentID,
		"players_enhanced": result.PlayersEnhanced,
		"players_skipped":  result.PlayersSkipped,
		"errors":           result.Errors,
		"duration":         result.Duration.String(),
	})
}

// RefreshPlayerData refreshes enhanced data for a contest
func (h *EnhancedPlayerHandler) RefreshPlayerData(c *gin.Context) {
	contestIDStr := c.Param("contest_id")
	contestID, err := uuid.Parse(contestIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid contest ID"})
		return
	}

	if err := h.tournamentEnricher.RefreshEnhancedData(context.Background(), contestID); err != nil {
		h.logger.WithError(err).Error("Failed to refresh player data")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to refresh player data"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":    "Player data refreshed successfully",
		"contest_id": contestID,
	})
}

// GetUnmatchedPlayers returns players that couldn't be matched with tournament data
func (h *EnhancedPlayerHandler) GetUnmatchedPlayers(c *gin.Context) {
	contestIDStr := c.Param("contest_id")
	contestID, err := uuid.Parse(contestIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid contest ID"})
		return
	}

	players, err := h.playerMatcher.GetUnmatchedPlayersForContest(context.Background(), contestID)
	if err != nil {
		h.logger.WithError(err).Error("Failed to get unmatched players")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get unmatched players"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"contest_id":        contestID,
		"unmatched_count":   len(players),
		"unmatched_players": players,
	})
}

// GetContestsByDataSource returns contests filtered by player data source
func (h *EnhancedPlayerHandler) GetContestsByDataSource(c *gin.Context) {
	dataSource := c.DefaultQuery("data_source", "enhanced")
	limit := c.DefaultQuery("limit", "10")
	
	limitInt, err := strconv.Atoi(limit)
	if err != nil {
		limitInt = 10
	}

	var contests []types.Contest
	query := h.db.Table("contests").
		Select("contests.*, COUNT(players.id) as player_count").
		Joins("LEFT JOIN players ON contests.id = players.contest_id AND players.data_source = ?", dataSource).
		Group("contests.id").
		Having("COUNT(players.id) > 0").
		Order("contests.start_time DESC").
		Limit(limitInt)

	if err := query.Find(&contests).Error; err != nil {
		h.logger.WithError(err).Error("Failed to get contests by data source")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get contests"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"data_source": dataSource,
		"contests":    contests,
	})
}