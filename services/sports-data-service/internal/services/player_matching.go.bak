package services

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/sirupsen/logrus"
	"github.com/stitts-dev/dfs-sim/shared/pkg/database"
	"github.com/stitts-dev/dfs-sim/shared/types"
	"gorm.io/gorm"
)

// PlayerMatch represents a match between contest and tournament players
type PlayerMatch struct {
	ID                  uuid.UUID `gorm:"type:uuid;primary_key;default:gen_random_uuid()" json:"id"`
	ContestPlayerID     string    `gorm:"not null" json:"contest_player_id"`
	TournamentPlayerID  string    `gorm:"not null" json:"tournament_player_id"`
	MatchConfidence     float64   `gorm:"not null;default:0.95" json:"match_confidence"`
	MatchMethod         string    `gorm:"not null" json:"match_method"`
	PlayerID            uuid.UUID `gorm:"not null" json:"player_id"`
	CreatedAt           time.Time `gorm:"default:now()" json:"created_at"`
	UpdatedAt           time.Time `gorm:"default:now()" json:"updated_at"`
}

// TableName returns the table name for PlayerMatch
func (PlayerMatch) TableName() string {
	return "player_matches"
}

// MatchMethod constants
const (
	MatchMethodExactName    = "exact_name"
	MatchMethodFuzzyName    = "fuzzy_name"
	MatchMethodExternalID   = "external_id"
	MatchMethodManual       = "manual"
)

// PlayerMatchingService handles matching contest players with tournament players
type PlayerMatchingService struct {
	db     *database.DB
	logger *logrus.Logger
}

// NewPlayerMatchingService creates a new player matching service
func NewPlayerMatchingService(db *database.DB, logger *logrus.Logger) *PlayerMatchingService {
	return &PlayerMatchingService{
		db:     db,
		logger: logger,
	}
}

// TournamentPlayer represents a player from tournament data
type TournamentPlayer struct {
	ExternalID string
	Name       string
	Team       string
	Position   string
}

// MatchPlayersForContest matches contest players with tournament players
func (pms *PlayerMatchingService) MatchPlayersForContest(ctx context.Context, contestID uuid.UUID, tournamentPlayers []TournamentPlayer) error {
	logger := pms.logger.WithFields(logrus.Fields{
		"component":          "player_matching",
		"contest_id":         contestID,
		"tournament_players": len(tournamentPlayers),
	})

	logger.Info("Starting player matching for contest")

	// Get all contest players
	var contestPlayers []types.Player
	if err := pms.db.WithContext(ctx).Where("contest_id = ? AND data_source = ?", contestID, "contest").Find(&contestPlayers).Error; err != nil {
		return fmt.Errorf("failed to get contest players: %w", err)
	}

	if len(contestPlayers) == 0 {
		logger.Warn("No contest players found for matching")
		return nil
	}

	logger.WithField("contest_players", len(contestPlayers)).Info("Found contest players to match")

	matched := 0
	failed := 0

	// Create a map for efficient tournament player lookup
	tournamentPlayerMap := make(map[string]TournamentPlayer)
	for _, tp := range tournamentPlayers {
		tournamentPlayerMap[strings.ToLower(tp.Name)] = tp
	}

	// Try to match each contest player
	for _, contestPlayer := range contestPlayers {
		match, confidence, method := pms.findBestMatch(contestPlayer, tournamentPlayers, tournamentPlayerMap)
		
		if match != nil {
			if err := pms.createPlayerMatch(ctx, contestPlayer, *match, confidence, method); err != nil {
				logger.WithError(err).WithField("player", contestPlayer.Name).Error("Failed to create player match")
				failed++
				continue
			}
			matched++
		} else {
			logger.WithField("player", contestPlayer.Name).Warn("No match found for contest player")
			failed++
		}
	}

	logger.WithFields(logrus.Fields{
		"matched": matched,
		"failed":  failed,
	}).Info("Player matching completed")

	return nil
}

// findBestMatch finds the best tournament player match for a contest player
func (pms *PlayerMatchingService) findBestMatch(contestPlayer types.Player, tournamentPlayers []TournamentPlayer, tournamentPlayerMap map[string]TournamentPlayer) (*TournamentPlayer, float64, string) {
	// Method 1: Exact name match
	if match, exists := tournamentPlayerMap[strings.ToLower(contestPlayer.Name)]; exists {
		return &match, 1.0, MatchMethodExactName
	}

	// Method 2: Fuzzy name matching
	bestMatch, bestScore := pms.fuzzyNameMatch(contestPlayer.Name, tournamentPlayers)
	if bestMatch != nil && bestScore >= 0.8 {
		return bestMatch, bestScore, MatchMethodFuzzyName
	}

	// Method 3: External ID matching (if available)
	// This would require tournament players to have external IDs
	// For now, we'll skip this method

	return nil, 0.0, ""
}

// fuzzyNameMatch performs fuzzy name matching
func (pms *PlayerMatchingService) fuzzyNameMatch(contestName string, tournamentPlayers []TournamentPlayer) (*TournamentPlayer, float64) {
	var bestMatch *TournamentPlayer
	var bestScore float64 = 0.0

	contestNameLower := strings.ToLower(contestName)
	contestParts := strings.Fields(contestNameLower)

	for _, tp := range tournamentPlayers {
		tournamentNameLower := strings.ToLower(tp.Name)
		score := pms.calculateNameSimilarity(contestNameLower, tournamentNameLower, contestParts)
		
		if score > bestScore {
			bestScore = score
			bestMatch = &tp
		}
	}

	return bestMatch, bestScore
}

// calculateNameSimilarity calculates similarity between two names
func (pms *PlayerMatchingService) calculateNameSimilarity(name1, name2 string, name1Parts []string) float64 {
	// Simple similarity based on common words and substring matching
	if name1 == name2 {
		return 1.0
	}

	// Check if one name contains the other
	if strings.Contains(name1, name2) || strings.Contains(name2, name1) {
		return 0.95
	}

	name2Parts := strings.Fields(name2)
	commonWords := 0
	totalWords := len(name1Parts)

	// Count common words
	for _, part1 := range name1Parts {
		for _, part2 := range name2Parts {
			if part1 == part2 {
				commonWords++
				break
			}
		}
	}

	if totalWords == 0 {
		return 0.0
	}

	// Calculate similarity as ratio of common words
	similarity := float64(commonWords) / float64(totalWords)

	// Bonus for having both first and last name match
	if len(name1Parts) >= 2 && len(name2Parts) >= 2 {
		firstNameMatch := name1Parts[0] == name2Parts[0]
		lastNameMatch := name1Parts[len(name1Parts)-1] == name2Parts[len(name2Parts)-1]
		
		if firstNameMatch && lastNameMatch {
			similarity = 1.0
		} else if firstNameMatch || lastNameMatch {
			similarity += 0.2
		}
	}

	return similarity
}

// createPlayerMatch creates a player match record
func (pms *PlayerMatchingService) createPlayerMatch(ctx context.Context, contestPlayer types.Player, tournamentPlayer TournamentPlayer, confidence float64, method string) error {
	// Check if match already exists
	var existingMatch PlayerMatch
	err := pms.db.WithContext(ctx).Where("contest_player_id = ? AND tournament_player_id = ?", 
		*contestPlayer.ContestPlayerID, tournamentPlayer.ExternalID).First(&existingMatch).Error
	
	if err == nil {
		// Update existing match
		updates := map[string]interface{}{
			"match_confidence": confidence,
			"match_method":     method,
			"updated_at":       time.Now(),
		}
		
		if err := pms.db.WithContext(ctx).Model(&existingMatch).Updates(updates).Error; err != nil {
			return fmt.Errorf("failed to update player match: %w", err)
		}
		
		pms.logger.WithFields(logrus.Fields{
			"contest_player":    contestPlayer.Name,
			"tournament_player": tournamentPlayer.Name,
			"confidence":        confidence,
			"method":            method,
		}).Debug("Updated existing player match")
		
		return nil
	}

	// Create new match
	match := PlayerMatch{
		ContestPlayerID:    *contestPlayer.ContestPlayerID,
		TournamentPlayerID: tournamentPlayer.ExternalID,
		MatchConfidence:    confidence,
		MatchMethod:        method,
		PlayerID:           contestPlayer.ID,
		CreatedAt:          time.Now(),
		UpdatedAt:          time.Now(),
	}

	if err := pms.db.WithContext(ctx).Create(&match).Error; err != nil {
		return fmt.Errorf("failed to create player match: %w", err)
	}

	// Update contest player with tournament player ID
	if err := pms.db.WithContext(ctx).Model(&contestPlayer).Update("tournament_player_id", tournamentPlayer.ExternalID).Error; err != nil {
		pms.logger.WithError(err).Warn("Failed to update contest player with tournament player ID")
	}

	pms.logger.WithFields(logrus.Fields{
		"contest_player":    contestPlayer.Name,
		"tournament_player": tournamentPlayer.Name,
		"confidence":        confidence,
		"method":            method,
	}).Debug("Created new player match")

	return nil
}

// GetPlayerMatches retrieves all player matches for a contest
func (pms *PlayerMatchingService) GetPlayerMatches(ctx context.Context, contestID uuid.UUID) ([]PlayerMatch, error) {
	var matches []PlayerMatch
	err := pms.db.WithContext(ctx).
		Joins("JOIN players ON player_matches.player_id = players.id").
		Where("players.contest_id = ?", contestID).
		Find(&matches).Error
	
	if err != nil {
		return nil, fmt.Errorf("failed to get player matches: %w", err)
	}

	return matches, nil
}

// GetMatchedPlayersForContest retrieves contest players with their tournament matches
func (pms *PlayerMatchingService) GetMatchedPlayersForContest(ctx context.Context, contestID uuid.UUID) ([]types.Player, error) {
	var players []types.Player
	err := pms.db.WithContext(ctx).
		Where("contest_id = ? AND tournament_player_id IS NOT NULL", contestID).
		Find(&players).Error
	
	if err != nil {
		return nil, fmt.Errorf("failed to get matched players: %w", err)
	}

	return players, nil
}

// GetUnmatchedPlayersForContest retrieves contest players without tournament matches
func (pms *PlayerMatchingService) GetUnmatchedPlayersForContest(ctx context.Context, contestID uuid.UUID) ([]types.Player, error) {
	var players []types.Player
	err := pms.db.WithContext(ctx).
		Where("contest_id = ? AND tournament_player_id IS NULL", contestID).
		Find(&players).Error
	
	if err != nil {
		return nil, fmt.Errorf("failed to get unmatched players: %w", err)
	}

	return players, nil
}

// DeletePlayerMatchesForContest removes all player matches for a contest
func (pms *PlayerMatchingService) DeletePlayerMatchesForContest(ctx context.Context, contestID uuid.UUID) error {
	// Get all player IDs for the contest
	var playerIDs []uuid.UUID
	err := pms.db.WithContext(ctx).
		Model(&types.Player{}).
		Where("contest_id = ?", contestID).
		Pluck("id", &playerIDs).Error
	
	if err != nil {
		return fmt.Errorf("failed to get player IDs: %w", err)
	}

	// Delete matches for these players
	result := pms.db.WithContext(ctx).Where("player_id IN ?", playerIDs).Delete(&PlayerMatch{})
	if result.Error != nil {
		return fmt.Errorf("failed to delete player matches: %w", result.Error)
	}

	// Clear tournament player IDs from contest players
	if err := pms.db.WithContext(ctx).
		Model(&types.Player{}).
		Where("contest_id = ?", contestID).
		Update("tournament_player_id", nil).Error; err != nil {
		pms.logger.WithError(err).Warn("Failed to clear tournament player IDs")
	}

	pms.logger.WithFields(logrus.Fields{
		"contest_id":      contestID,
		"matches_deleted": result.RowsAffected,
	}).Info("Deleted player matches for contest")

	return nil
}

// CreateManualMatch creates a manual match between contest and tournament players
func (pms *PlayerMatchingService) CreateManualMatch(ctx context.Context, contestPlayerID, tournamentPlayerID string) error {
	// Get contest player
	var contestPlayer types.Player
	if err := pms.db.WithContext(ctx).Where("contest_player_id = ?", contestPlayerID).First(&contestPlayer).Error; err != nil {
		return fmt.Errorf("contest player not found: %w", err)
	}

	// Create tournament player struct (would normally come from API)
	tournamentPlayer := TournamentPlayer{
		ExternalID: tournamentPlayerID,
		Name:       "Manual Match", // This would come from API
	}

	return pms.createPlayerMatch(ctx, contestPlayer, tournamentPlayer, 1.0, MatchMethodManual)
}

// GetMatchingStats returns statistics about player matching for a contest
func (pms *PlayerMatchingService) GetMatchingStats(ctx context.Context, contestID uuid.UUID) (map[string]interface{}, error) {
	var totalPlayers int64
	var matchedPlayers int64
	var unmatchedPlayers int64

	// Count total players
	if err := pms.db.WithContext(ctx).Model(&types.Player{}).Where("contest_id = ?", contestID).Count(&totalPlayers).Error; err != nil {
		return nil, fmt.Errorf("failed to count total players: %w", err)
	}

	// Count matched players
	if err := pms.db.WithContext(ctx).Model(&types.Player{}).
		Where("contest_id = ? AND tournament_player_id IS NOT NULL", contestID).
		Count(&matchedPlayers).Error; err != nil {
		return nil, fmt.Errorf("failed to count matched players: %w", err)
	}

	unmatchedPlayers = totalPlayers - matchedPlayers

	// Get matching method breakdown
	var methodStats []struct {
		Method string
		Count  int64
	}
	
	err := pms.db.WithContext(ctx).
		Table("player_matches").
		Select("match_method as method, COUNT(*) as count").
		Joins("JOIN players ON player_matches.player_id = players.id").
		Where("players.contest_id = ?", contestID).
		Group("match_method").
		Scan(&methodStats).Error
	
	if err != nil {
		return nil, fmt.Errorf("failed to get method stats: %w", err)
	}

	stats := map[string]interface{}{
		"total_players":     totalPlayers,
		"matched_players":   matchedPlayers,
		"unmatched_players": unmatchedPlayers,
		"match_rate":        float64(matchedPlayers) / float64(totalPlayers),
		"method_breakdown":  methodStats,
	}

	return stats, nil
}